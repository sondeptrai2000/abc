var EventEmitter = require('events').EventEmitter
  , file = require('./file')
  , stdin = require('./stdin');

/**
 * Frame a stream so that \n separated lines are emitted as the 'data' event.
 *
 * @param {ReadableStream|String} input (optional) - a stream, filename, or null for stdin
 * @return {ReadableStream} output
 * @api public
 */

module.exports = function (input) {
    if (!input) {
        input = stdin();
    } else if (typeof input === 'string') {
        input = file(input);
    }

    if (input._line_stream) {
        return input;
    }

    var buffer_len, buffer = new Buffer(buffer_len = 0)
      , encoding, output = new EventEmitter
      , paused, pause_buffer = [], pause_buffer_len = 0;

    output._line_stream = true;

    input.on('data', function (chunk) {
        var len = chunk.length
          , previous = buffer
          , nl_pos = 0;

        //Make sure we're working with a buffer
        if (!(chunk instanceof Buffer)) {
            chunk = new Buffer(chunk, len);
        }

        //Merge the chunk and previous buffer
        buffer = new Buffer(len + buffer_len);
        previous.copy(buffer, 0, 0, buffer_len);
        chunk.copy(buffer, buffer_len, 0, len);
        buffer_len += len;

        //Emit each line in the buffer
        for (var i = 0, line; i < buffer_len; i++) {
            if (buffer[i] === 10) { //\n
                line = buffer.slice(nl_pos, i);
                line = encoding ? line.toString(encoding) : line
                if (!paused) {
                    output.emit('data', line);
                } else {
                    pause_buffer.push(line);
                    pause_buffer_len++;
                }
                nl_pos = i + 1;
            }
        }

        buffer_len -= nl_pos;
        buffer = buffer.slice(nl_pos);
    });

    input.on('end', function () {
        if (buffer_len) {
            output.emit('data', encoding ? buffer.toString(encoding) : buffer);
        }
        output.emit('end');
    });

    Object.defineProperty(output, 'readable', {
        get: function () {
            return input.readable;
        }
    });

    output.pause = function () {
        paused = true;
        input.pause();
    };

    output.resume = function () {
        paused = false;
        for (var i = 0, line; i < pause_buffer_len; i++) {
            line = pause_buffer[i];
            output.emit('data', encoding ? line.toString(encoding) : line);
        }
        pause_buffer = [];
        pause_buffer_len = 0;
        input.resume();
    };

    input.on('error', function (err) {
        output.emit('error', err);
    });

    input.on('close', function () {
        output.emit('close');
    });

    output.destroySoon = function() {
        input.destroySoon();
    }

    output.setEncoding = function (enc) {
        encoding = enc;
    };

    input.resume();

    return output;
};

